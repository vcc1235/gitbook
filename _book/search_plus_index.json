{"./":{"url":"./","title":"说明","keywords":"","body":"Alete开发 Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-08 "},"html/iOS/iOS.html":{"url":"html/iOS/iOS.html","title":"iOS","keywords":"","body":"Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-08 "},"html/iOS/router.html":{"url":"html/iOS/router.html","title":"Router 解耦","keywords":"","body":"引言 软件程序设计一个永恒的主题就是高内聚底耦合,因为高耦合的代码在前期的问题不会很突出，而且代码有可能不低耦合的看起来更为直接简洁，开发的时候更方便，但是每个程序代码都有可能发生迭代，因此随着每个版本的迭代高耦合的代码模块的维护和新添的功能就会越来越困难，调试也会越来越难，导致牵一发而动全身的高耦合的代码面临的选择不多了,重构是其中的选择，但是现实中重构需要成本和时间的，不一定得到其他项目人员的理解... 所以最开始低耦合是相对比较好的选择，这样避免的后续问题。 iOS解耦机制 delegate 代理模式 block 模式 notification 通知中心 KVO 键值观察 delegate 与 block 解耦的作用相同，都是委托模式 需要双方同意 notification 作为通知中心虽然可以起到解耦的作用，但是会消耗大量的资源并且效果并不是很好 KVO 作为黑科技之一，属性键-值观察 与notification 都是属于观察者模式 解耦目的 解耦的目的是各个模块相互调用时没有相互关联，按照指定协议进行运行工作 ，模块之间组件化也会减少干扰解耦思路 内部控制器之间的跳转 利用字符串转目标控制器 ,KVC模式进行传入参数,block回调收集目标控制器完成的一系列操作 指定方法的调用 实例方法调用 : 需要传入实例 与 方法字符串 , 通过block回调传入参数 返回执行结果 类方法调用 : 传入类名 与 方法名称 ， 通过block回调传入参数 返回执行结果 外部链接方式跳转 外部链接进行解析拆成指定方法 然后执行 1 或者2Router实现 跳转模式 typedef NS_OPTIONS(NSInteger, RTTransition){ /// present 跳转 RTTransitionPresent, /// push 跳转 RTTransitionPush, /// present 跳转 (带导航栏) RTTRansitionNAVPresent, /// 无需跳转 用作创建控制器 RTTransitionNone }; block回调 typedef void(^RTCompletion)(NSError * __nullable error, id __nullable obj); 给控制器添加协议 @protocol RouterParamDelegate /// 参数 @property (nonatomic, strong) NSDictionary *routerParams ; /// 跳转完成后回调操作 @property (nonatomic, strong) RTCompletion routerCompletion ; @optional /// 需要参数的属性列表 利用 KVC 模式传参 -(NSArray*)routerTopropertys ; @end /// 设置类别 代理模式 @interface UIViewController (RouterDelegate) @end /// runtime 类别储存属性值 @implementation UIViewController (RouterDelegate) -(NSDictionary *)routerParams{ return objc_getAssociatedObject(self, @\"routerparams\"); } -(void)setRouterParams:(NSDictionary *)routerParams{ [self willChangeValueForKey:@\"routerparams\"]; objc_setAssociatedObject(self, @\"routerparams\", routerParams, OBJC_ASSOCIATION_RETAIN_NONATOMIC); [self didChangeValueForKey:@\"routerparams\"]; } -(void)setRouterCompletion:(RTCompletion)routerCompletion{ [self willChangeValueForKey:@\"routerCompletion\"]; objc_setAssociatedObject(self, @\"routerCompletion\", routerCompletion, OBJC_ASSOCIATION_RETAIN_NONATOMIC); [self didChangeValueForKey:@\"routerCompletion\"]; } -(RTCompletion)routerCompletion{ return objc_getAssociatedObject(self, @\"routerCompletion\"); } @end 外部链接打开App是检测的链接的代理 @protocol RouterHandelDelegate @required -(NSString *)host ; /** 检测是否为登录状态 */ -(BOOL)isLogin ; @optional -(void)transitionWithTargetName:(NSString *)viewControllerName Params:(NSDictionary *__nullable)params ; @end 执行方法时需要传入参数对象 /// 数据操作 传出参数按顺序对应 @interface RouterModel : NSObject @property (nonatomic, strong) id first ; @property (nonatomic, strong) id second ; @property (nonatomic, strong) id third ; @property (nonatomic, strong) id fouth ; @property (nonatomic, strong) id fifth ; @property (nonatomic, strong) id sex ; @end 路由执行对象 @interface Router : NSObject /// 跳转 导航类 +(void)navigationController:(Class)className ; /// 项目名设置 主要针对 swift 控制器的跳转 +(BOOL)swiftClassWithProjectName:(NSString *)projectName; /// 处理外部跳转 +(BOOL)routerHandleOpenURL:(NSURL *)url withDelegate:(id)delegate ; /** 进行跳转调整 @param target 操作控制器 @param viewControllerName 目标控制器名 @param params 传入参数 @param transition 跳转模式 @return 目标控制器 */ +(UIViewController *)transitionWithSource:(UIViewController *__nullable)target Target:(NSString *__nonnull)viewControllerName Params:(NSDictionary *__nullable)params TransitionMode:(RTTransition)transition ; /** 进行跳转调整 @param target 操作控制器 @param viewControllerName 目标控制器名 @param params 传入参数 @param transition 跳转模式 @param complete 操作完成 @return 目标控制器 */ +(UIViewController *)transitionWithSource:(UIViewController *__nullable)target Target:(NSString *__nonnull)viewControllerName Params:(NSDictionary *__nullable)params TransitionMode:(RTTransition)transition complete:(RTCompletion __nullable)complete ; /** 方法的执行 @param targetName 执行者名 @param selectorName 执行方法名 @param params 参数传递 @return 返回值 */ +(id)performTarget:(NSString *)targetName selectorName:(NSString *)selectorName Params:(void(^)(RouterModel *make))params ; /** 方法执行 @param target target description @param selectorName selectorName description @param params params description @return return value description */ +(id)performObject:(NSObject *)target selectorName:(NSString *)selectorName Params:(void (^)(RouterModel * _Nonnull))params ; @end Router的实现 基础配置 配置导航栏对象 swift跳转需要工程名 static NSString *__projectName = @\"IM\" ; static Class __className ; @implementation Router +(void)navigationController:(Class)className{ __className = className ; } +(BOOL)swiftClassWithProjectName:(NSString *)projectName{ __projectName = projectName ; return true ; } 外部链接打开App是解析链接 /// url 为外部连接 +(BOOL)routerHandleOpenURL:(NSURL *)url withDelegate:(id)delegate{ NSString *viewControllerName ; if (![delegate isLogin]) { return false ; } NSMutableDictionary *param = [[NSMutableDictionary alloc]init]; if (![url.host isEqualToString:delegate.host]) { viewControllerName = @\"web\" ; NSString *http = [NSString stringWithFormat:@\"http://%@%@?%@\",url.host,url.path,url.query]; [param setObject:http forKey:@\"url\"]; [delegate transitionWithTargetName:viewControllerName Params:param]; return true ; } NSString *path = url.path ; if (path && path.length>0) { path = [url.path substringFromIndex:1] ; NSArray *paths = [path componentsSeparatedByString:@\"/\"]; viewControllerName = paths.firstObject ; }else{ path = url.host ; } NSString *query = url.query; if (query && query.length>0) { NSArray *querys = [query componentsSeparatedByString:@\"&\"]; [querys enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { if ([obj containsString:@\"=\"]) { NSRange range = [obj rangeOfString:@\"=\"]; NSString *key = [obj substringToIndex:range.location]; NSString *value = [obj substringFromIndex:range.location+1]; [param setObject:value forKey:key]; } }]; } /// 数据解析成可执行的格式 [delegate transitionWithTargetName:viewControllerName Params:param]; return true ; } 控制器切换跳转实现 /** 本地组件(控制器)切换 @param target 调用者 @param viewControllerName targetName @param params params @param transition transition @return UIViewController object */ +(UIViewController *)transitionWithSource:(UIViewController *)target Target:(NSString *)viewControllerName Params:(NSDictionary *)params TransitionMode:(RTTransition)transition complete:(RTCompletion)complete{ UIViewController *viewController; if (NSClassFromString(viewControllerName)) { viewController = [[NSClassFromString(viewControllerName) class] new]; }else if(NSClassFromString([NSString stringWithFormat:@\"%@.%@\",__projectName,viewControllerName])){ viewController = [[NSClassFromString([NSString stringWithFormat:@\"%@.%@\",__projectName,viewControllerName]) class]new]; } if (viewController == nil) { // 处理无响应请求的地方之一。 // 可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求 return nil; } if (![viewController isKindOfClass:[UIViewController class]]) { return nil; } /// 判断执行跳转对象 if ([target isKindOfClass:[UIViewController class]]) { target = (UIViewController *)target; } else { target = [UIApplication sharedApplication].keyWindow.rootViewController; } /// KVC 给目标对象传值 避免目标对象的穿插 if ([viewController respondsToSelector:@selector(routerTopropertys)]) { NSArray*list = [viewController routerTopropertys]; for (NSString *key in list) { id object = [params objectForKey:key]; if (object != nil) { /// KVC [viewController setValue:object forKey:key]; } } } viewController.routerParams = params ; viewController.routerCompletion = complete /// 判断跳转方式 switch (transition) { case RTTransitionPush: { if (!target.navigationController) { return viewController; } if ([target.navigationController.viewControllers count]==1) { viewController.hidesBottomBarWhenPushed = YES; } [target.navigationController pushViewController:viewController animated:true]; }break; case RTTransitionPresent: { [target presentViewController:viewController animated:true completion:nil]; }break; case RTTRansitionNAVPresent: { UINavigationController *navigationController ; if (__className) { navigationController = [[__className alloc]initWithRootViewController:viewController]; }else{ navigationController = [[UINavigationController alloc]initWithRootViewController:viewController]; } [target presentViewController:navigationController animated:YES completion:nil]; }break ; case RTTransitionNone: { return viewController; break; } } /// 返回目标控制器对象 return viewController; } 实例方法的调用 /// target 目标实例 selectorName 被执行方法名 params 按顺序传入参数 +(id)performObject:(NSObject *)target selectorName:(NSString *)selectorName Params:(void (^)(RouterModel * _Nonnull))params{ if (target == nil) { // 处理无响应请求的地方之一。 // 可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求,也可以跳转App内url。 return nil; } SEL action = NSSelectorFromString(selectorName); if (action == nil) { // 处理无响应请求的地方之一。 // 可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求 return nil; } RouterModel *model = [[RouterModel alloc]init]; if (params) { /// 执行block接收参数 params(model); } // 可以响应 说明方法可执行 if ([target.class respondsToSelector:action] || [target respondsToSelector:action]) { return [self performTarget:target Action:action Params:model]; } // 有可能target是Swift对象 NSString *actionString = [NSString stringWithFormat:@\"%@WithParams:\", selectorName]; action = NSSelectorFromString(actionString); // 可以响应 if ([target respondsToSelector:action]) { return [self performTarget:target Action:action Params:model]; } // 处理无响应请求的地方之二 // 如果无响应，则尝试调用对应target的notFound方法统一处理 action = NSSelectorFromString(@\"notFound:\"); if ([target respondsToSelector:action]) { return [self performTarget:target Action:action Params:model]; } else { // 处理无响应请求的地方之三， // 在notFound都没有的时候，可以用之前的固定的target顶上 return nil; } } 私有方法 具体执行 /** 私有方法，perform @param target target @param action action @param model params @return return value of method peformed */ +(id)performTarget:(NSObject *)target Action:(SEL)action Params:(RouterModel *)model { NSMethodSignature* methodSig; // 优先调用类方法 if ([target.class respondsToSelector:action]) { methodSig = [target.class methodSignatureForSelector:action]; } else { methodSig = [target methodSignatureForSelector:action]; } if(methodSig == nil) { return nil; } // 获取invocation NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSig]; // 入参 进行参数传入 for (NSInteger idx = 2; idx 类方法执行 /** 本地组件调用 @param targetName targetName @param selectorName actionName @param params params @return return value of method maped action */ +(id)performTarget:(NSString *)targetName selectorName:(NSString *)selectorName Params:(void(^)(RouterModel *make))params{ NSObject *target; if (NSClassFromString(targetName)) { target = [[NSClassFromString(targetName) class] new]; }else{ return nil ; } if (target == nil) { // 处理无响应请求的地方之一。 // 可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求,也可以跳转App内url。 return nil; } SEL action = NSSelectorFromString(selectorName); if (action == nil) { // 处理无响应请求的地方之一。 // 可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求 return nil; } RouterModel *model = [[RouterModel alloc]init]; if (params) { params(model); } // 可以响应 if ([target.class respondsToSelector:action] || [target respondsToSelector:action]) { return [self performTarget:target Action:action Params:model]; } // 有可能target是Swift对象 NSString *actionString = [NSString stringWithFormat:@\"%@WithParams:\", selectorName]; action = NSSelectorFromString(actionString); // 可以响应 if ([target respondsToSelector:action]) { return [self performTarget:target Action:action Params:model]; } // 处理无响应请求的地方之二 // 如果无响应，则尝试调用对应target的notFound方法统一处理 action = NSSelectorFromString(@\"notFound:\"); if ([target respondsToSelector:action]) { return [self performTarget:target Action:action Params:model]; } else { // 处理无响应请求的地方之三， // 在notFound都没有的时候，可以用之前的固定的target顶上 return nil; } } Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-08 "},"html/iOS/api.html":{"url":"html/iOS/api.html","title":"Api管理","keywords":"","body":"iOS 多个后台接口 颜色 图片 国际化等配置你确定会集中管理.... 引言 在iOS开发过程中一边会遇到后台接口会连接多个服务器,每个地方都在用颜色 图片，在项目最开始时候用起来确实便捷，但是一个项目会出想迭代的情况，后台更改服务器，接口时候怎么能一次性更改或者更换图片的时候你会发现需要改的地方太多了，如果需求增加主题更换呢？所以这些配置系列的东西都需要集中管理 解决方案 后台接口与颜色配置 利用json文件或者plist文件配置后台与颜色值，通过单例解析方式调取对应所需的值 图片集中管理 图片使用需要考虑主题更换和网络更换主题 ，所以考虑用bundle包模式来使用图片 解决用法 后台接口管理 json文件内容格式如下 打包工程师可以使用加密工具进行加密json文件 代码解密使用 这样避免解包是泄露接口 { \"UserApi\":{ ## 用户模块 \"host\":\"http://xxx.xxx/xx\", ## 主机地址 \"loginString\":\"/api/login\" ## 登录 }, \"IMApi\":{ ## 其他模块 \"host\":\"\", \"loginString\":\"dffdasfdsafdsafds\" ## } } UserApi IMApi 建议首字母大写 单例封装讲解 @interface VCApiManager () /// 储存json文件内容 @property (nonatomic, strong) NSDictionary *dictioanry ; @end -(void)reloadApi{ NSArray *classArray = self.dictioanry.allKeys ; // 类名 for (NSString *classString in classArray) { if (classString == nil || classString.length==0) { continue ; } id objc = [[NSClassFromString(classString) alloc]init]; // 实例化类 if (objc == nil) { NSLog(@\"%@ class is null\",classString); continue ; } // KVC 给单例设置属性值 [self setValue:objc forKey:[self lowercastFirstString:classString]]; /// json 二级 NSDictionary *valueDictionary = [self.dictioanry valueForKey:classString]; /// 获取服务地址 NSString *host = [valueDictionary valueForKey:@\"host\"]; if (host == nil) { host = [objc valueForKey:@\"host\"]; if (host == nil) { host = self.host; } } unsigned int propertyCount = 0; /// 获取实例属性 objc_property_t *properties = class_copyPropertyList(object_getClass(objc), &propertyCount); for (unsigned int i = 0; i 使用方式 @interface UserApi : NSObject /// 登录 @property (nonatomic, strong) NSString *loginString ; @end /// 继承单例 @interface ApiShare : VCApiManager /// 用户模块 @property (nonatomic, strong) UserApi *userApi ; @end /// 直接使用 ApiShare.shareInstance.userApi.loginString 就可以获取登录接口 颜色集中管理也是类似的 json文件格式如下 { \"default\":{ ## 默认使用颜色 \"navigationTitleColor\":\"#ffffff\" }, \"sim\":{ ## 其他主题颜色 \"navigationTitleColor\":\"#000000\" } } 单例模式如后台api几种管理类似 解析json文件赋值到新的对象上 直接调用即可 也方便切换主题颜色 图片的集中管理模式 创建一个默认的bundle包 创建一个实例管理bundle包 // bundle包的路径 切换主题即更换bundle包即可 -(void)setImageBundle:(NSString *)path{ NSString *url = [NSBundle.mainBundle pathForResource:path ofType:nil]; if (url) { self.bundleString = path ; }else{ NSBundle *bundle = [NSBundle bundleWithPath:path]; if (bundle) { self.bundleString = bundle.bundlePath ; } } } UIImage交换方法 +(void)load{ __weak typeof(self) weakSelf = self; static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ Class class = [weakSelf class]; Method oldMethod = class_getClassMethod(class, @selector(imageNamed:)); Method newMethod = class_getClassMethod(class, @selector(imageCustomName:)); method_exchangeImplementations(oldMethod, newMethod); }); } +(UIImage *)imageCustomName:(NSString *)name{ /// 过滤 if (AFBundleManager.shareBundleManager.imageNames && [AFBundleManager.shareBundleManager.imageNames containsObject:name]) { return [UIImage imageCustomName:name]; } /// 访问图片是 指向指定的bundle包里的图片 NSString *img = [NSString stringWithFormat:@\"%@/%@\",AFBundleManager.shareBundleManager.bundleString,name]; return [UIImage imageCustomName:img]; } 使用方式 [UIImage imageNamed:\"\"]; // 使用系统方法即可 切换主题直接更换访问的bundle包即可 也可以从服务器上下载bundle包(每个包对应的图片的名字要一致) 国际化 创建一个xxx.bundle包 bundle包的文件夹使用各语言简称 解析bundle包 /// 设置语言bundle包 -(void)setBundlePath:(NSString *)path type:(NSInteger)type{ self.resourceName = path ; self.type = type ; [self setProjectLanguage]; } /// 切换语言 -(void)setLanguage:(NSString *)language{ [[NSUserDefaults standardUserDefaults] setObject:language forKey:@\"sys_language\"]; [[NSUserDefaults standardUserDefaults] synchronize]; [self setProjectLanguage]; } /// 更新语言 -(void)setProjectLanguage{ // 然后将设置好的语言存储好，下次进来直接加载 [[NSUserDefaults standardUserDefaults] setObject:self.currentLanguage forKey:@\"sys_language\"]; [[NSUserDefaults standardUserDefaults] synchronize]; if (self.type == 1) { NSBundle *fbundle = [NSBundle bundleWithPath:[NSBundle.mainBundle pathForResource:self.resourceName ofType:@\"bundle\"]]; objc_setAssociatedObject(NSBundle.mainBundle, &_bundlekey, self.currentLanguage ? [NSBundle bundleWithPath:[fbundle pathForResource:self.currentLanguage ofType:@\"lproj\"]] : nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC); }else if (self.type == 2){ NSBundle *fbundle = [NSBundle bundleWithPath:self.resourceName]; objc_setAssociatedObject(NSBundle.mainBundle, &_bundlekey, self.currentLanguage ? [NSBundle bundleWithPath:[fbundle pathForResource:self.currentLanguage ofType:@\"lproj\"]] : nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC); }else{ objc_setAssociatedObject(NSBundle.mainBundle, &_bundlekey, self.currentLanguage ? [NSBundle bundleWithPath:[NSBundle.mainBundle pathForResource:self.currentLanguage ofType:@\"lproj\"]] : nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } } -(NSString *)currentLanguage{ NSString *savedLanguage = [[NSUserDefaults standardUserDefaults] objectForKey:@\"sys_language\"]; return savedLanguage ?: [[NSBundle mainBundle] preferredLocalizations].firstObject; } 使用方式 就用系统方式调用即可 static const char *_bundlekey = \"_bundle_key\"; /// 继承NSBundle 使用方式 @interface Language : NSBundle @end @implementation Language /// 重写国际化调用语言的方法 -(NSString *)localizedStringForKey:(NSString *)key value:(NSString *)value table:(NSString *)tableName { NSBundle *bundle = objc_getAssociatedObject(self, &_bundlekey); return bundle ? [bundle localizedStringForKey:key value:value table:tableName] : [super localizedStringForKey:key value:value table:tableName]; } @end 后序 这些集中管理方便后续迭代 ，也可以用于组件化与模块化的开发，能够使每个模块进行独立避免交叉。如有更好建议希望不吝啬赐教！ Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-08 "},"html/Javascript/javascript.html":{"url":"html/Javascript/javascript.html","title":"JavaScript","keywords":"","body":"Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-08 "},"html/Javascript/jquery.html":{"url":"html/Javascript/jquery.html","title":"jQuery","keywords":"","body":"Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-08 "},"html/Javascript/jquery-select.html":{"url":"html/Javascript/jquery-select.html","title":"选择器","keywords":"","body":"jQuery Select jQuery 选择器允许对HTML元素组或者单个元素进行操作 元素选择器 $(document).ready(function(){ $(\"div\").click(function(){ $(\"p\").hide(); }); }); id 选择器 $(function(){ $(\"button\").click(function(){ $(\"#test\").hide(); }); }); class 选择器 $(function(){ $(\"button\").click(function(){ $(\".test\").hide(); }); }); 全选(*) $(function(){ $(\"button\").click(function(){ $(\"*\").hide(); }); }); 其他选择器 语法 描述 $(this)a 选取当前HTML元素 $(\"a.class\") 选取class=\"class\"的a元素 $(\"a:first\") 选取第一个a元素 $(\"ul li:first\") 选取第一个ul元素的第一个li元素 $(\"ul li:first-child\") 选取每个ul元素的第一个li元素 $(\"[src]\") 选取带有src属性的元素 $(\"a[target='_blank']\") 选取所有target的值为\"_blank\"的a元素 $(\"a[target!='_blank']\") 选取所有target的值不为\"_blank\"的a元素 $(\":button\") 选取所有type=\"button\"的input元素和button元素 $(\"tr:even\") 选取偶数位的tr元素 $(\"tr:odd\") 选取奇数位的tr元素 Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-08 "},"html/Javascript/click.html":{"url":"html/Javascript/click.html","title":"事件","keywords":"","body":"jquery 事件 click() 点击触发事件 $(function () { $(\"button\").click(function () { console.log(\"点击事件\"); }); }); dblclick() 双击元素触发事件 $(function () { $(\"button\").dblclick(function () { console.log(\"双击事件\"); }); }); mouseenter() 鼠标放到元素上触发事件 $(function () { $(\"button\").mouseenter(function () { console.log(\"鼠标穿过元素\"); }); }); mouseleave() 鼠标离开元素时触发事件 $(function () { $(\"button\").mouseleave(function () { console.log(\"鼠标离开事件\"); }); }); mouseup() 当元素上的鼠标松开时触发事件 $(function () { $(\"button\").mouseup(function () { console.log(\"鼠标松开时触发事件\"); }); }); mousedown() 当鼠标按下时触发事件 $(function () { $(\"button\").mousedown(function () { console.log(\"鼠标按下时触发事件\"); }); }); hover() 当鼠标悬停在元素上触发事件 $(function () { $(\"button\").hover(function () { console.log(\"鼠标悬停在元素上事件\"); }); }); focus() 当元素获取焦点时触发事件 $(function () { $(\"input#test\").focus(function () { console.log(\"获取焦点事件\"); }); }); blur() 当元素失去焦点时触发事件 $(function () { $(\"input#test\").blur(function () { console.log(\"元素失去焦点时触发的事件\"); }) }) Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-08 "},"html/Java/java.html":{"url":"html/Java/java.html","title":"Java","keywords":"","body":"Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-08 "},"html/Java/mysql/xcc-mysql.html":{"url":"html/Java/mysql/xcc-mysql.html","title":"mysql","keywords":"","body":"Mysql 与 Entity 仓库 com-vcc-mapper http://maven.xalete.com/maven 根据sql 文件创建 dao模型 mapper.xml service com.vcc mapper 1.0.0 public static void main(String[] args) { String path = Sql.class.getClassLoader().getResource(\"demo.yml\").getPath(); JavaShell javaShell = new JavaShell(path); javaShell.createJavaFile(); javaShell.createMapperXML(); } mapper: sql: E:\\\\vcc\\\\mall.sql ### 数据库地址 dao: com.vcc.demo.jinxun.dao ### model 模型 mapper: com.vcc.demo.jinxun.mapper ### mapper 地址 service: com.vcc.demo.jinxun.service # service 地址 mapperxml: src/main/resources/mapper/ ### xml 地址 md: src/main/resource/sql.md ### md 说明 根据model 来创建 表 com.xcc.imx mysql 1.0.0 启动添加指定包名 @SpringBootApplication(scanBasePackages = {\"com.xcc.sql\"}) 配置 yml mybatis: model: pack: com.xcc.xos.main.entity ## 指定model报名 configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl ### sql 语句打印 可不要 config-locations: classpath*:com/xcc/sql/mapper/*.xml ### 指定mapper.xml model 注解 package com.xcc.xos.main.entity; import ... /** * @description: 文件模型 * @author: 123 * @create: 2020-08-05 16:52 **/ @Data @XTable(name = \"file\") // 表名称 public class FileEntity { // name 字段名 type 字段类型 length 字段长度 isKey 是否为主键 isNull 是否可以为空 // isAutoIncrement 是否自增 commonValue 注释 @XColumn(name = \"id\", type = MysqlTypeConstant.INT, length = 32, isKey = true, isNull = false, isAutoIncrement = true, commonValue = \"id\") private Integer id; @XColumn(name = \"name\", type = MysqlTypeConstant.VARCHAR, isNull = false, commonValue = \"文件名称\") private String name; @XColumn(name = \"type\", type = MysqlTypeConstant.VARCHAR, isNull = false, commonValue = \"文件类型\") private String type; @XColumn(name = \"url\", type = MysqlTypeConstant.VARCHAR, commonValue = \"文件url\") private String url; @XColumn(name = \"parent\", type = MysqlTypeConstant.INT, isNull = false, commonValue = \"父类id\") private Integer parent; @XColumn(name = \"is_file\", type = MysqlTypeConstant.TINYINT, length = 1, isNull = false, commonValue = \"是否是文件\") private boolean file; @XColumn(name = \"is_status\", type = MysqlTypeConstant.TINYINT, length = 1, isNull = false, commonValue = \"是否是私有文件\") private boolean status; @XColumn(name = \"create_time\", type = MysqlTypeConstant.DATETIME, commonValue = \"创建时间\") private Date createTime; // isAutoUpdateTime 时间是否自动更新 @XColumn(name = \"update_time\", type = MysqlTypeConstant.DATETIME, commonValue = \"更新时间\", isAutoUpdateTime = true) private Date updateTime; } 启动即可更具model 生成对应的表 自带一些数据库操作 public interface IAbstractTableService { int insertOne(T var1); int insertMany(List var1); T getOne(LinkedHashMap var1); int getCount(LinkedHashMap var1); List getList(int var1, int var2); List getList(int var1, int var2, String var3); List getList(LinkedHashMap var1, int var2, int var3); List getList(LinkedHashMap var1, int var2, int var3, String var4); List getList(LinkedHashMap var1); List getList(LinkedHashMap var1, String var2); int update(T var1); int update(LinkedHashMap var1, LinkedHashMap var2); int delete(LinkedHashMap var1); } // 接口类 @Service(\"IAbstractTableService\") public class AbstractTableServiceImpl implements IAbstractTableService { // 实现类 ， 使用时继承即可 // 子类必须重写该方法 返回对应model 类 public Class getTypeClass() { return null; } } Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-18 "},"html/java/docker.html":{"url":"html/java/docker.html","title":"docker","keywords":"","body":"Docker Dockerfile 镜像配置文件 FROM centos:7 WORKDIR /usr RUN mkdir /usr/local/java ADD jdk /usr/local/java ENV JAVA_HOME /usr/local/java ENV JRE_HOME ${JAVA_HOME}/jre ENV CLASSPATH .:${JAVA_HOME}/lib:${JRE_HOME}/lib ENV PATH ${JAVA_HOME}/bin:$PATH ## 生成镜像文件 docker build -t jdk:8 . 创建容器 # 文件软连接 -v 载体目录(文件):容器目录(文件) --name 容器名称 -p 载体端口号:容器端口号 docker run -it --name xxx -v 宿机目录(文件):容器目录(文件) --privileged -p 宿机端口:容器端口 -d 镜像 Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-18 "},"html/Server/server.html":{"url":"html/Server/server.html","title":"服务器","keywords":"","body":"Linux Centos 常用环境安装 引用来源 来源:https://oneinstack.com/ 默认安装路径都在 /usr/local/ 服务 Liunx+Nginx+MySQL/MongoDB+PHP Liunx+Apache+MySQL/MongoDB+PHP Linux + Nginx+ MySQL/MongoDB+ PHP+ Apache Linux + Nginx+ MySQL/MongoDB+ Tomcat Linux + Nginx+ PostgreSQL+ PHP Linux + Apache+ PostgreSQL+ PHP Linux + Nginx+ MySQL+ HHVM ## Linux + Nginx+ MySQL+ Tomcat+Redis 安装命令 wget -c http://mirrors.linuxeye.com/oneinstack-full.tar.gz && tar xzf oneinstack-full.tar.gz && ./oneinstack/install.sh --nginx_option 1 --tomcat_option 2 --jdk_option 2 --db_option 2 --dbinstallmethod 1 --dbrootpwd oneinstack --redis --memcached --reboot ## 也可以选择性安装 wget -c http://mirrors.linuxeye.com/oneinstack-full.tar.gz && tar xzf oneinstack-full.tar.gz && ./oneinstack/install.sh ## 执行完会出现对应的安装选择 Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-18 "},"html/Server/nginx.html":{"url":"html/Server/nginx.html","title":"nginx","keywords":"","body":"Nginx conf文件夹为配置文件夹 .conf 为服务器配置文件 worker_processs 1 ; # 阻塞和非阻塞网络模型 # 同步阻塞模型，一请求一进(线)程,当进（线）程增加到一定程度后 # 更多cpu时间浪费到切换一，性能急剧下降，所以负载率不高 # Nginx 基于时间的非阻塞多路复用(epoll或kquene)模型 # 一个进程在短时间内可以响应大量的请求 # 建议值 events events{ ## nginx最大的负载量 ## 并发响应的关键配置值 ## 每个进程允许的最大同时连接数 work_connections*worker_processes=maxConnection; ## 因为一般一个浏览器会同时开两条连接，如果反向代理，nginx到后端服务器的连接也要占用连接数 # 所以 做静态服务器时，一般 maxClient = work_connections*worker_processes/2 # 做反向代理时 maxClient = work_connections*worker_processes/4 ## 这个值理论上越大越号，但是最多可承受多少请求与配件和网络相关 ，也可最大可打开文件 ，最大可用sockets数量 worker_connections 1024 ; ## 指明使用epoll 或者 kquene（*BSD) use epoll ; # 备注 要达到超高负载下最好的网络响应能力，还有必要优化与网络相关的liunx内核参数 multi_accept on; ### 设置一个进程是否同时接受多个网络连接 默认 off } http access_log xxxx ## 访问日志 error_log xxxx ## 异常日志 crit xxxx ## 错误级别 http{ include mime.types ## 引入外部配置文件 default_type application/octet-stream ; ## 默认接收格式 ## 启用内核复制模式 保持开启达到最快IO效率 sendfile on; upstream mysvr{ server 127.0.0.1:8080 ; server 127.0.0.1:3000 ; ## 热备 } error_page 404 https://xxxx.com ; ## 错误页 ## 启动时 会在数据包达到一定的大小后再发送数据 ## 减少网络通信次数 降低阻塞概率 但是会影响响应的及时性 ## 比较适合文件下载这类大数据包通信场景 # tcp_nopush on ; # tcp_nodelay on|off on禁用Nagle算法 ## HTTP1.1 支持持久连接 alive keepalive_timeout 30s; ## 开启压缩 gzip on; gzip_min_length 100 ; gzip_comp_level 4 ; gzip_types text/plain text/cess application/json application/x-javascript text/xml application include 配置文件 ## 配置文件分开设置 } server server{ listen 80 ; ## 监听端口 http访问端口 server_name xxxx.com ; ### 指定访问 域名 rewrite ^(.*) https://$host$1 permanent ; ### 指向https 操作 } server{ listen 443; ## 监听端口 https访问端口 server_name xxxx.com; ## 访问主机 可以是域名 root /home/www ; ## 目录 access_log /home/log/nginx/access_log combined; ### 日志位置 index index.html index.htm index.php ; ### 指定默认访问文件 ssl on; ## 开启 ssl验证 ssl_certificate /certifier/ssl/xxxx.pem ; ## pem格式证书 ssl_certificate_key /certifier/ssl/xxxx.key; ## key格式证书 ssl_session_timeout 5m ; ## 超时设置 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; ssl_prefer_server_ciphers on; ## 执行路径 location / { ## 默认路径 如：https://xxxx.com/ root html ; ## 指定目录 } location /list{ ## 访问如： https://xxxx.com/list 进入 root html } location /proxy{ ## 访问如: https://xxxx.com/proxy 进入 proxy_pass http://mysvr/proxy; ## 转发到访问: http:mysvr/proxy => http://127.0.0.1:8080/proxy 或者 http://127.0.0.1:3000/proxy 中 # 可以更改或添加客户端的请求头部信息内容并转发至后端服务器，比如在后端服务器想要获取客户端的真实IP的时 候，就要更改每一个报文的头部，如下： proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; deny 127.0.0.1; ## 拒绝指定ip访问 allow 192.168.0.116 ; ## 允许指定ip访问 } location ~ \\.php$ { ### 针对php的访问 # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; } } Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-08 "},"html/Server/gitLab.html":{"url":"html/Server/gitLab.html","title":"gitLab","keywords":"","body":"gitLab 的安装 创建或者修改 yum源 vim /etc/yum.repos.d/gitlab-ce.repo gitlab-ce.repo内容 name=Gitlab CE Repository baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/ gpgcheck=0 enabled=1 更新yum缓存 yum makecache 安装 gitlab-ce yum install gitlab-ce 修改配置文件 vim /etc/gitlab/gitlab.rb gitlab.rb文件 external_url http://192.168.0.120:3005 # URL on which GitLab will be reachable ## 下面gitlab_rails 配置 如 gitlab['time_zone']='Beijing' gitlab_email_from 邮箱地址 gitlab_email_display_name 昵称 如：GitLab ## SMTP 配置 smtp_enable true smtp_address smtp服务地址 如：smtp.163.com smtp_port 465 smtp_user_name 发送端邮箱地址 对应平台 smtp_password 授权码 smtp_domain smtp服务地址 smtp_authentication login user['git_user_email'] 与发送地址一样 重新加载配置 gitlab-ctl reconfigure 重新启动 gitlab-ctl restart 查看日志 gitlab-ctl tail Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-08 "},"html/Server/Rabbit.html":{"url":"html/Server/Rabbit.html","title":"Rabbit","keywords":"","body":"RabbitMQ 安装 (erlang作为支撑) RabbitMQ 下载地址 https://www.rabbitmq.com/releases/rabbitmq-server/ 选择 rabbitmq-server-generic 版本 由于 liunx版本安装包末尾为xz结尾 需执行 xz -d rabbitmq-server-generic.**.xz 解压 rabbitmq-server-generic.**.tar 设置环境变量 /etc/profile ==> PATH=$PATH:/sbin Erlang 下载地址 http://www.erlang.org/downloads 选择20 左右版本即可 解压安装包 进入安装包 创建安装目录 /usr/local/erlang 执行 ./configure --prefix=/usr/local/erlang 执行 make && make install 设置环境变量 /etc/profile ==> PATH=/usr/local/erlang/bin:$PATH 使环境变量生效 source /etc/profile RabbitMQ操作 select option 启动 rabbitmq-server -detached 查看状态 rabbitmqctl status 关闭服务 rabbitmqctl stop 启动插件 rabbitmq-plugins enable rabbitmq_managerment 查看mq用户 rabbitmqctl list_users 查看用户权限 rabbitmqctl list_user_permissions guest 新增用户 rabbitmqctl add_user admin 123456 赋予管理员权限 rabbitmqctl set_user_tags admin administrator Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-08 "},"html/Server/mongodb.html":{"url":"html/Server/mongodb.html","title":"mongodb","keywords":"","body":"Mongodb 安装 下载地址 https://www.mongodb.com/download-center/community 选择对应的版本 获取对应版本下载地址 例如： https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.6.16.tg 解压 文件 移动到指定的位置 例如： /usr/local/mongodb 创建文件夹 ## 创建数据库存放文件夹 mkdir /usr/local/mongodb/data ## 创建配置文件夹 mkdir /usr/local/mongodb/etc ## 创建日志文件夹 mkdir /usr/local/mongodb/log 设置配置 ### 进入配置文件夹 cd /usr/local/mongodb/etc ### 创建配置文件夹 vim mongodb.conf ### 配置文件内容 ## 数据库 dbpath=/usr/local/mongodb/data ## 日志 logpath=/usr/local/mongodb/log/mongodb.log ## 端口号 port= 27017 ## 绑定ip访问 #bind_ip=127.0.0.1 只允许本机访问 bind_ip=0.0.0.0 #所有主机都可以访问 # 权限 auth=false ## 关闭认证 Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-08 "},"html/Server/redis.html":{"url":"html/Server/redis.html","title":"redis","keywords":"","body":"Redis 文件 bin 文件 redis-benchmark ## 用于redis 性能测试 redis-check-aof ## 用于redis 修复工作 redis-check-rdb ## 用于redis 数据修复 redis-cli ## 模拟redis客户端，进行连接redis,操作redis redis-sentinel ## redis的哨兵模式，用于解决redis高可用性解决方案 redis-server ## redis 服务 启动 etc redis.conf ## redis 配置文件 sentinel.conf ## 哨兵模式配置文件 var dump.rdb ## redis数据库配置文件 redis.log ## redis 日志文件 操作 启动 ### 全局启动 service redis-server start ### 自定义启动 redis-server 指定配置文件 --port 端口号 配置文件 redis.conf bind 127.0.0.1 ## 绑定可访问主机地址 例如：0.0.0.0 指的所有主机都可以访问 daemonize yes ## redis默认不是守护进程方式运行 修改配置启动守护进程 pidfile /usr/local/redis/redis.pid ### 指定pid文件路径 port 6379 ### 指定redis启动端口号 timeout 300 ## 客户端闲置多长时间关闭连接 如果为0 则永不关闭 tcp-keeplive 0 ## 检测客户端网络中断时间间隔 如果为0 则永不检测 loglevel verbose ## 指定日志记录级别 debug verbose notice warning logfile stdout ## 日志记录方式 默认标准输出 databases 16 ##设置数据库的数量 默认值16 save 300 10 ## 表示300秒内有10个更改就将数据同步到数据文件 ##指定存储至本地数据库时是否压缩数据，默认为yes，redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变得巨大： rdbcompassion yes ## 指定本地数据库文件名，默认值为dump.rdb： dbfilename dump.rdb ## 指定本地数据库存放目录 dir ./ ## 设置当本机为slave服务时，设置master服务的IP地址及端口，在redis启动时，它会自动从master进行数据同步 slaveof ## 当master服务设置了密码保护时，slave服务连接master的密码 masterauth ## 设置redis连接密码，如果配置了连接密码，客户端在连接redis时需要通过auth 命令提供密码，默认关闭 requirepass 123456 ## 设置同一时间最大客户端连接数，默认无限制即0 maxclients 128 ## 指定redis最大内存限制，redis在启动时会把数据加载到内存中，达到最大内存后，redis会先尝试清除已到期或即将到期的key，当次方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制， 会把key存放内存，value会存放在swap区 maxmemory ## 设置缓存过期策略 maxmemory-policy noeviction ## 指定是否在每次更新操作后进行日志记录，redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内数据丢失。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内置存在于内存中。默认为no appendonly no ## 指定更新日志文件名，默认为appendonly.aof appendfilename appendonly.aof ## 指定更新日志条件 no:表示等操作系统进行数据缓存同步到磁盘（快) always: 表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） everysec:表示每秒同步一次（折中，默认值） appendfsync everysec ## 指定是否启用虚拟内存机制，默认值为no，简单介绍一下，VM机制将数据分页存放，由redis将访问量较小的页即冷数据 swap到磁盘上，访问多的页面由磁盘自动换出到内存中 vm-enabled no ## 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个redis实例共享 vm-swap-file /tmp/redis.swap ## 将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多小，所有索引数据都是内存存储的（redis的索引数据就是keys），也就是说，当vm-max-memory设置为0的时候，其实是所有value都存在于磁盘。默认值为 0 vm-max-memory 0 ## redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是根据存储的数据大小来设定的，作者建议如果储存很多小对象，page大小最好设置为32或者64bytes；如果存储很多大对象，则可以使用更大的page，如果不确定，就使用默认值 vm-page-size 32 ## 设置swap文件中page数量，由于页表（一种表示页面空闲或使用的bitmap）是放在内存中的，在磁盘上每8个pages将消耗1byte的内存 vm-pages 134217728 ## 设置访问swap文件的线程数，最好不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成长时间的延迟。默认值为4 vm-max-threads 4 ## 设置在客户端应答时，是否把较小的包含并为一个包发送，默认为开启 glueoutputbuf yes ## 指定在超过一定数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-entries 64 hash-max-zipmap-value 512 ## 指定是否激活重置hash，默认开启 activerehashing yes ## 指定包含其他配置文件，可以在同一主机上多个redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 include /path/to/local.conf Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-08 "},"html/Resource/resource.html":{"url":"html/Resource/resource.html","title":"资源文件","keywords":"","body":"资源文件 (window) Xshell6 提取码ykdf Xftp6 提取码tin2 Navicat 提取码8g8o XMind 提取码y5n9 Office2016 提取码n6mk IDEA 提取码3qq2 Window激活 提取码csbo IDEA A82DEE284F-eyJsaWNlbnNlSWQiOiJBODJERUUyODRGIiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-5epo90Xs7KIIBb8ckoxnB/AZQ8Ev7rFrNqwFhBAsQYsQyhvqf1FcYdmlecFWJBHSWZU9b41kvsN4bwAHT5PiznOTmfvGv1MuOzMO0VOXZlc+edepemgpt+t3GUHvfGtzWFYeKeyCk+CLA9BqUzHRTgl2uBoIMNqh5izlDmejIwUHLl39QOyzHiTYNehnVN7GW5+QUeimTr/koVUgK8xofu59Tv8rcdiwIXwTo71LcU2z2P+T3R81fwKkt34evy7kRch4NIQUQUno//Pl3V0rInm3B2oFq9YBygPUdBUbdH/KHROyohZRD8SaZJO6kUT0BNvtDPKF4mCT1saWM38jkw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g== Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-08 "},"html/Resource/mac.html":{"url":"html/Resource/mac.html","title":"mac","keywords":"","body":"Copyright © xalete.com 2019 all right reserved，powered by Gitbookmodfiy time 2020-08-08 "}}